<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Pixel Fill Benchmark</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			#container {
				background: #000;
			}
			
			body {
				font-family: Monospace;
				<!--background: #000; -->
				background: #f0f0f0; 
				background-color: #f0f0f0; 
				margin: 0px;
				overflow: hidden;
			}
		</style>
	</head>
	<body>

		<script src="../../build/three.min.js"></script>
		<script src="../js/Detector.js"></script>
		<script src="../js/libs/stats.js-r9/src/Stats.js"></script>
		<script src="../../test/benchmark/benchmark-1.0.0.js"></script>
		
		<!-- <script src="js/libs/stats-new.min.js"></script>			//custom
		//<script src="js/libs/stats.min - Copy.js"></script>		//original -->
		
		<text id="STATUS_ID" style="position: absolute; top:100px">Status: </text>
		
		<script>

		var numObjects = 2000;					//max objects
		var targetFPS = 50;						//highest fps before adding objects
		var varyFPS = targetFPS / 10;			//allowed range of FPS
		var	lowestFPS = targetFPS - varyFPS;	//lowest FPS before taking out objects
		
		var startVal = 50;						//starting object number
		
		var removeNum = startVal;				//mesh array position, for removing objects
		var container, stats;
		var camera, renderer;
		var scene = new THREE.Scene();
		var geometry, material, material2;
		//var geometries = new THREE.CubeGeometry(10);
		var meshes = new Array(numObjects);
		var colors = new Array(numObjects);
		var addFlag = 0;						// -1 = remove, 1 = add, 0 = nothing
		var waitFrames = 60;						// wait time between adding/removing objects
		var waitTime = 0;						// amount of frames to wait
		
		var windowHalfX = window.innerWidth / 2;
		var windowHalfY = window.innerHeight / 2;

		var targetRotation = 0;
		var targetRotationOnMouseDown = 0;

		var mouseX = 0;
		var mouseXOnMouseDown = 0;

		var runs = 0;
		
		var timebefore = 0;
		var timeafter = 0;
		
		function runBenchmark () 
		{
			var suite = new Benchmark.Suite;
			
			// add tests
			suite.add('fillrate', function() {
			  //mydiv.insertAdjacentHTML('beforeend', '<span></span>');
			  //render();
			  //console.log("inside the fill rate test");
			  //console.log("fillrate-benchmark");
			  //init();
			  //number++;
			  runs = runs + 1;
			  //console.log("run #: ", runs);
			  //init();
			  //animate();
			  
			  //var TargetFPS = document.getElementById('STATUS_ID');
			//TargetFPS.innerHTML = "Target FPS: " +runs;
			  
			  //requestAnimationFrame( animate );
			
			//fps meter update
			//stats.update();
			
			//rotate camera position
			//var timer = Date.now() * 0.0002;
			//camera.position.x = Math.cos( timer ) * 2000;
			//camera.position.z = Math.sin( timer ) * 2000;
			//camera.lookAt( scene.position );
			 
			//renderer.render( scene, camera );
			  
			})
			
			suite.add('test2', function() {
			  //mydiv.insertAdjacentHTML('beforeend', '<span></span>');
			  //render();
			  //console.log("inside the fill rate test");
			  console.log("test2-benchmark");
			  //init();
			  //number++;
			  runs = runs + 1;
			  //init();
			  //animate();
			  
			  //var TargetFPS = document.getElementById('STATUS_ID');
			//TargetFPS.innerHTML = "Target FPS: " +runs;
			  
			  //requestAnimationFrame( animate );
			
			//fps meter update
			//stats.update();
			
			//rotate camera position
			//var timer = Date.now() * 0.0002;
			//camera.position.x = Math.cos( timer ) * 2000;
			//camera.position.z = Math.sin( timer ) * 2000;
			//camera.lookAt( scene.position );
			 
			//renderer.render( scene, camera );
			  
			})
			 
			// Additional options for the test
			
			 .on('setup', function() {
				console.log("setup");
				//var mydiv = document.getElementById('mydiv');
				//time = performance.now();
				//runs = runs + 1;
			  })
			  .on('teardown', function() {
				console.log("teardown");
				//mydiv.innerHTML = '';
				//endtime = performance.now();
				//console.log("difference: ", endtime - time);
				//console.log("pluck test: " +this.filter(fastest).pluck('name') );
				//console.log('Fastest is ' + this.filter('fastest').pluck('name'));
				//console.log('Fastest is ' + this.filter('successful').pluck('name'));
			  })
			  .on('start', function() {
				console.log("benchmark start");
				
			  })
			  // add listeners
			  .on('cycle', function(event) {
				console.log("cycle");
				console.log(String(event.target));
			  })
			  // 
			  .on('complete', function() {
				console.log("complete");
				console.log('Fastest is ' + this.filter('fastest').pluck('name'));
				console.log('minTime is ' + this.filter('successful').pluck('minTime'));
				console.log('maxTime is ' + this.filter('successful').pluck('maxTime'));
				console.log('stats: ' + this.filter('successful').pluck('stats.variance'));
			  })
			  .on('abort', function() {
				console.log("abort");
			  })
		
		//suite.run();
		
		}
	
		
		//Check that browser supports WebGL, else exit nicely
		 if (Detector.webgl) {
			 init();
			 console.log("begin animate");
			 animate();
			 //requestAnimationFrame( animate );
			 
			//renderer.render( scene, camera );
			//runBenchmark();
		 } else {	
			 var warning = Detector.getWebGLErrorMessage();
			 document.getElementById('container').appendChild(warning);
		 }   

		function init() 
		{
			container = document.createElement( 'div' );
			document.body.appendChild( container );
			
			// camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 1000 );
			// camera.position.set( 0, 150, 500 );
		
			camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 10000 );
			camera.position.y = window.innerHeight / 2;
			camera.position.z = 1000;
			camera.position.set( 2500, 2500, 500 );

			//make square used to be here
			makeSquare();

			//renderer = new THREE.CanvasRenderer();
			renderer = new THREE.WebGLRenderer();
			renderer.setSize( window.innerWidth, window.innerHeight );
			renderer.sortObjects = false;
			renderer.sortElements = false;
			container.appendChild( renderer.domElement );
			
			//add stats
			stats = new Stats();
			
			//older way to add statistics object
			stats.getDomElement().style.position = 'absolute';
			stats.getDomElement().style.left = '0px';
			stats.getDomElement().style.top = '0px';
			document.body.appendChild( stats.getDomElement() );

			// new way to do add statistics object
			//stats.domElement.style.position = 'absolute';
			//stats.domElement.style.top = '0px';
			//container.appendChild( stats.domElement );
			
			// document.addEventListener( 'mousedown', onDocumentMouseDown, false );
			// document.addEventListener( 'touchstart', onDocumentTouchStart, false );
			// document.addEventListener( 'touchmove', onDocumentTouchMove, false );

			// //

			// window.addEventListener( 'resize', onWindowResize, false );
		}

		function addShape( shape, color, x, y, z, rx, ry, rz, s ) 
		{

			// flat shape
			var geometry = new THREE.ShapeGeometry( shape );
			var material = new THREE.MeshBasicMaterial( { color: color, overdraw: true } );

			var mesh = new THREE.Mesh( geometry, material );
			mesh.position.set( x, y, z );
			mesh.rotation.set( rx, ry, rz );
			mesh.scale.set( s, s, s );
			scene.add( mesh );

			// line
			var geometry = shape.createPointsGeometry();
			var material = new THREE.LineBasicMaterial( { linewidth: 10, color: 0x333333, transparent: true } );

			var line = new THREE.Line( geometry, material );
			line.position.set( x, y, z );
			line.rotation.set( rx, ry, rz );
			line.scale.set( s, s, s );
			scene.add( line );
		}
		
		function makeSquare() 
		{
			// Square
			var sqLength = 80;
			var x = 5000; //window.innerWidth;
			var y = 5000; //window.innerHeight;
			
			//console.log("window.innerWidth: ", window.innerWidth);
			//console.log("window.innerHeight: ", window.innerHeight);

			var squareShape = new THREE.Shape();
			squareShape.moveTo( 0,0 );
			squareShape.lineTo( 0, y );
			squareShape.lineTo( x, y );
			squareShape.lineTo( x, 0 );
			squareShape.lineTo( 0, 0 );
			
			//scene.add(squareShape);
			addShape( squareShape, 0x0055ff, 150, 100, 0, 0, 0, 0, 1 );
		}
		
		function animate() 
		{
			// note: three.js includes requestAnimationFrame shim
			requestAnimationFrame( animate );
			
			//fps meter update
			stats.update();
			
			if(waitTime == 0)
			{			
				console.log("MAKE SQUARE!");
				var i;
				for(i = 0; i < 200; i++)
				{
					makeSquare();
				}
				
				console.log("TIMING THE RENDER");
				var timebefore = performance.now();
				//console.log("before: ", timebefore);
				renderer.render( scene, camera );
				var timeafter = performance.now();
				//console.log("after: ", timeafter);
				
				if(timeafter-timebefore > 0)
				{
					console.log("difference: ", timeafter-timebefore);
				}
				
				//clear square
				waitTime = waitFrames;
				
			}
			else
			{
				//render the blank scene and wait
				removeSceneObjects();
				renderer.render( scene, camera );
				waitTime--;
			}
		}
		
		function removeSceneObjects ()
		{
			var obj, i;
			console.log("scene.children.length: ", scene.children.length);
			for ( i = scene.children.length - 1; i >= 0 ; i -- ) 
			{
				obj = scene.children[i];
				if (obj !== camera) 
				{
					scene.remove(obj);	
				}
			}
			console.log("scene.children.length: ", scene.children.length);
		}
		
		function onWindowResize() {

				windowHalfX = window.innerWidth / 2;
				windowHalfY = window.innerHeight / 2;

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			//

			function onDocumentMouseDown( event ) {

				event.preventDefault();

				document.addEventListener( 'mousemove', onDocumentMouseMove, false );
				document.addEventListener( 'mouseup', onDocumentMouseUp, false );
				document.addEventListener( 'mouseout', onDocumentMouseOut, false );

				mouseXOnMouseDown = event.clientX - windowHalfX;
				targetRotationOnMouseDown = targetRotation;

			}

			function onDocumentMouseMove( event ) {

				mouseX = event.clientX - windowHalfX;

				targetRotation = targetRotationOnMouseDown + ( mouseX - mouseXOnMouseDown ) * 0.02;

			}

			function onDocumentMouseUp( event ) {

				document.removeEventListener( 'mousemove', onDocumentMouseMove, false );
				document.removeEventListener( 'mouseup', onDocumentMouseUp, false );
				document.removeEventListener( 'mouseout', onDocumentMouseOut, false );

			}

			function onDocumentMouseOut( event ) {

				document.removeEventListener( 'mousemove', onDocumentMouseMove, false );
				document.removeEventListener( 'mouseup', onDocumentMouseUp, false );
				document.removeEventListener( 'mouseout', onDocumentMouseOut, false );

			}

			function onDocumentTouchStart( event ) {

				if ( event.touches.length == 1 ) {

					event.preventDefault();

					mouseXOnMouseDown = event.touches[ 0 ].pageX - windowHalfX;
					targetRotationOnMouseDown = targetRotation;

				}

			}

			function onDocumentTouchMove( event ) {

				if ( event.touches.length == 1 ) {

					event.preventDefault();

					mouseX = event.touches[ 0 ].pageX - windowHalfX;
					targetRotation = targetRotationOnMouseDown + ( mouseX - mouseXOnMouseDown ) * 0.05;

				}

			}
		
		</script>

	</body>
</html>
